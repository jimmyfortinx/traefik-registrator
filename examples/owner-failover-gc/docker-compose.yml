services:
  consul:
    image: hashicorp/consul:1.20
    command: agent -dev -client=0.0.0.0
    healthcheck:
      test: ["CMD", "consul", "info"]
      interval: 5s
      timeout: 3s
      retries: 20

  whoami:
    image: traefik/whoami:v1.11
    labels:
      traefik.enable: "true"
      traefik.http.services.whoami.loadbalancer.server.port: "80"

  registrator-owner-a:
    image: traefik-registrator:test
    build:
      context: ../..
    depends_on:
      consul:
        condition: service_healthy
    environment:
      CONSUL_HTTP_ADDR: http://consul:8500
      POLL_INTERVAL: 2s
      GC_INTERVAL: 2s
      OWNER_ID: owner-a
      OWNER_HEARTBEAT_TTL: 6s
      OWNER_HEARTBEAT_PASS_INTERVAL: 2s
      ORPHAN_GRACE_PERIOD: 4s
      OWNER_DOWN_GRACE_PERIOD: 4s
      SERVICE_ID_PREFIX: owner-a-
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  registrator-owner-b:
    image: traefik-registrator:test
    build:
      context: ../..
    depends_on:
      consul:
        condition: service_healthy
    environment:
      CONSUL_HTTP_ADDR: http://consul:8500
      POLL_INTERVAL: 2s
      GC_INTERVAL: 2s
      OWNER_ID: owner-b
      OWNER_HEARTBEAT_TTL: 6s
      OWNER_HEARTBEAT_PASS_INTERVAL: 2s
      ORPHAN_GRACE_PERIOD: 4s
      OWNER_DOWN_GRACE_PERIOD: 4s
      SERVICE_ID_PREFIX: owner-b-
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  verify:
    image: python:3.13-alpine
    depends_on:
      consul:
        condition: service_healthy
      registrator-owner-a:
        condition: service_started
      registrator-owner-b:
        condition: service_started
      whoami:
        condition: service_started
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    command:
      - python
      - -c
      - |
        import http.client
        import json
        import socket
        import time
        import urllib.parse
        import urllib.request

        consul = "http://consul:8500"
        owner_service = "traefik-registrator-owner"
        owner_prefix = "traefik-registrator-owner-"
        owner_a = "owner-a"
        owner_b = "owner-b"
        owner_a_service = "registrator-owner-a"
        owner_b_service = "registrator-owner-b"
        docker_socket_path = "/var/run/docker.sock"

        class UnixHTTPConnection(http.client.HTTPConnection):
            def __init__(self, unix_path):
                super().__init__("localhost")
                self.unix_path = unix_path

            def connect(self):
                self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                self.sock.settimeout(5)
                self.sock.connect(self.unix_path)

        def docker_request(method, path):
            conn = UnixHTTPConnection(docker_socket_path)
            conn.request(method, path)
            resp = conn.getresponse()
            payload = resp.read()
            status = resp.status
            conn.close()
            return status, payload

        def consul_json(path):
            with urllib.request.urlopen(consul + path, timeout=3) as resp:
                return json.load(resp)

        def whoami_owners():
            encoded = urllib.parse.quote("whoami", safe="")
            instances = consul_json(f"/v1/catalog/service/{encoded}")
            owners = {}
            for inst in instances:
                meta = inst.get("ServiceMeta") or {}
                if meta.get("managed-by") != "traefik-registrator":
                    continue
                owner = (meta.get("owner-id") or "").strip()
                if owner == "":
                    continue
                owners.setdefault(owner, []).append(inst.get("ServiceID"))
            return owners

        def owner_states():
            encoded = urllib.parse.quote(owner_service, safe="")
            checks = consul_json(f"/v1/health/checks/{encoded}")
            states = {}
            for check in checks:
                service_id = (check.get("ServiceID") or "").strip()
                if not service_id.startswith(owner_prefix):
                    continue
                owner = service_id[len(owner_prefix):].strip()
                if owner == "":
                    continue
                states[owner] = (check.get("Status") or "").strip()
            return states

        def wait_until(description, predicate, timeout):
            deadline = time.time() + timeout
            last = None
            while time.time() < deadline:
                try:
                    result = predicate()
                    if result is True:
                        return
                    last = result
                except Exception as err:
                    last = str(err)
                time.sleep(1)
            raise RuntimeError(f"timeout waiting for {description}; last={last}")

        status, body = docker_request("GET", "/version")
        if status != 200:
            raise RuntimeError(f"docker /version failed with status {status}")
        docker_api_version = (json.loads(body.decode("utf-8")) or {}).get("ApiVersion", "")
        docker_api_prefix = f"/v{docker_api_version}" if docker_api_version else ""

        def inspect_container(container_ref):
            encoded = urllib.parse.quote(container_ref, safe="")
            status, body = docker_request("GET", f"{docker_api_prefix}/containers/{encoded}/json")
            if status != 200:
                raise RuntimeError(f"inspect {container_ref} failed with status {status}")
            return json.loads(body.decode("utf-8"))

        self_container_id = open("/etc/hostname", "r", encoding="utf-8").read().strip()
        compose_project = (
            ((inspect_container(self_container_id).get("Config") or {}).get("Labels") or {})
            .get("com.docker.compose.project", "")
            .strip()
        )
        if compose_project == "":
            raise RuntimeError("unable to detect compose project label from verify container")

        def find_service_container_id(service_name):
            filters = {
                "label": [
                    f"com.docker.compose.project={compose_project}",
                    f"com.docker.compose.service={service_name}",
                ]
            }
            encoded_filters = urllib.parse.quote(json.dumps(filters), safe="")
            status, body = docker_request("GET", f"{docker_api_prefix}/containers/json?all=1&filters={encoded_filters}")
            if status != 200:
                raise RuntimeError(f"list containers for service {service_name} failed with status {status}")
            items = json.loads(body.decode("utf-8"))
            if len(items) != 1:
                raise RuntimeError(f"expected exactly one container for {service_name}, got {len(items)}")
            return (items[0].get("Id") or "").strip()

        owner_a_container_id = find_service_container_id(owner_a_service)
        owner_b_container_id = find_service_container_id(owner_b_service)

        def container_state(container_name):
            details = inspect_container(container_name)
            state = details.get("State") or {}
            return {
                "running": bool(state.get("Running")),
                "paused": bool(state.get("Paused")),
            }

        def pause_container(container_name):
            encoded = urllib.parse.quote(container_name, safe="")
            status, _ = docker_request("POST", f"{docker_api_prefix}/containers/{encoded}/pause")
            if status not in (204, 304, 409):
                raise RuntimeError(f"pause {container_name} failed with status {status}")

        def both_owners_registered():
            owners = whoami_owners()
            states = owner_states()
            ready = (
                owner_a in owners
                and owner_b in owners
                and states.get(owner_a) == "passing"
                and states.get(owner_b) == "passing"
            )
            if ready:
                return True
            return {"owners": owners, "states": states}

        wait_until("both owner registrators to register whoami", both_owners_registered, timeout=90)

        pause_container(owner_a_container_id)

        wait_until(
            "owner-a container to pause",
            lambda: True if container_state(owner_a_container_id).get("paused") else {"owner_a_state": container_state(owner_a_container_id)},
            timeout=30,
        )

        def owner_a_services_cleaned_up():
            owners = whoami_owners()
            states = owner_states()
            owner_b_state = container_state(owner_b_container_id)
            owner_a_state = container_state(owner_a_container_id)
            cleaned = (
                owner_a not in owners
                and owner_b in owners
                and states.get(owner_b) == "passing"
                and states.get(owner_a) != "passing"
                and owner_b_state.get("running")
                and owner_a_state.get("paused")
            )
            if cleaned:
                return True
            return {
                "owners": owners,
                "states": states,
                "owner_b_state": owner_b_state,
                "owner_a_state": owner_a_state,
            }

        wait_until(
            "owner-b registrator to gc owner-a stale services",
            owner_a_services_cleaned_up,
            timeout=90,
        )
        print("owner-failover-gc scenario passed")
